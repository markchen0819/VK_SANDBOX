#version 450

struct Particle
{
	vec4 position;
    vec4 rotation;
    vec4 scale;
	vec4 velocity;
    vec4 color;

    vec4 startPosition;
    vec4 startRotation;
    vec4 startScale;
	vec4 startVelocity;

	float lifeTime;
    float remainingLifetime;
};

layout (std140, binding = 0) uniform ParameterUBO
{
    float deltaTime; 
    float accumulatedTime;
    int enableAdvection;
    float flowMaxVelocity;

    float flowWidth;
    int enablVortex; 
    float kappa;
    float tau; 

    int enableGravity;
	int enableBounce;
	float groundHeight;
	float restitution;

    int enableSpiral;
	int spiralWithGlobalAxis;
	float spiralRadius;
	float sprialAngularSpeed;

	float sprialAxisSpeed;
	int dummy1;
	int dummy2;
	int dummy3;

    vec4 flowDirection;
	vec4 flowCenter;
    vec4 vortexCenter;
	vec4 vortexAxis;
    vec4 gravity;

} ubo;

layout(std430, binding = 1) readonly buffer ParticleSSBOIn 
{
   Particle particlesIn[ ];
};

layout(std430, binding = 2) buffer ParticleSSBOOut 
{
   Particle particlesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
// Particle Count: 65536
// Thread Count per work group : 256
// Work Group Count: 65536/256
// Group1 0~255, Group2 256~511...

vec3 CalculateVortexVelocityAtPosition(vec3 position)
{
    float kappa = ubo.kappa; // rotation rate 
    float tau  = ubo.tau; //  tightness
    vec3 vortexCenter = ubo.vortexCenter.xyz;
    vec3 vortexAxis = ubo.vortexAxis.xyz;

    vec3 x = position - vortexCenter;  // Translate position relative to the vortex center
    float distanceSquared = dot(x, x); // Compute squared distance from V0 to the position
    float projectionSquared = dot(x, vortexAxis) * dot(x, vortexAxis); // Compute squared distance of the projection on u
    float rSquared = abs(distanceSquared - projectionSquared); // Squared orthogonal distance to the axis
    rSquared = max(rSquared, 1e-6); // Avoid division by zero
    vec3 velocity = kappa * cross(vortexAxis, x) / pow(rSquared, tau / 2.0); // Compute the velocity affected by the vortex at the particle's position
    
    return velocity;
}
vec3 CalculateFluidVelocityAtPosition(vec3 position)
{
    vec3 flowDirection = normalize(ubo.flowDirection.xyz);
    float maxVelocity = ubo.flowMaxVelocity;
    float flowWidth = ubo.flowWidth;
    vec3 flowCenter = ubo.flowCenter.xyz;

    // (u dot v) v
    vec3 flowCenterToParticleVector = position - flowCenter;
    vec3 parallelVec = dot(flowCenterToParticleVector, flowDirection) * flowDirection;
    vec3 verticalVec = flowCenterToParticleVector - parallelVec;
    float distanceFromCenter = length(verticalVec);
    float normalizedDistance = distanceFromCenter / (0.5 * flowWidth); // between 0 and 1
    normalizedDistance = clamp(normalizedDistance, 0.0, 1.0); // Clamp to valid range
    // Calculate velocity magnitude (higher in the center, lower near the edges)
    float velocityMagnitude = maxVelocity * (1.0 - normalizedDistance);
    vec3 velocity = velocityMagnitude * flowDirection;

    return velocity;
}
vec3 CalculateSpiralVelocity(vec3 velocity, vec3 position)
{
    int global = ubo.spiralWithGlobalAxis;
    if( global == 1) // Sprial around global y axis
    {
        float spiralRadius = ubo.spiralRadius;
        float sprialAngularSpeed = ubo.sprialAngularSpeed; 
        float sprialAxisSpeed = ubo.sprialAxisSpeed;

        float angleDisplacement = sprialAngularSpeed * ubo.deltaTime * 100;
        float heightDisplacement = sprialAxisSpeed * ubo.deltaTime * 100;
        float currentAngle = atan(position.z, position.x);
        float currentHeight = position.y;
        float newAngle = currentAngle + angleDisplacement;
        float newHeight = currentHeight + heightDisplacement;
        vec3 newPosition;
        newPosition.x = spiralRadius * cos(newAngle);
        newPosition.y = newHeight;
        newPosition.z = spiralRadius * sin(newAngle);
        vec3 spiralVelocity = newPosition - position;
        return spiralVelocity;
    }
    else // Sprial around individual y axis
    {
        vec3 axis = vec3(0,1,0);
        float sigma = ubo.sprialAngularSpeed; // Angular speed
        float angle = sigma * ubo.accumulatedTime;
        float cosTheta = cos(angle);
        float sinTheta = sin(angle);
        // angle axis rotation (Rodrigues rotation formula)
        vec3 rotatedVelocity = velocity * cosTheta + //  Parallel to the plane of rotation remains unchanged in magnitude but is rotated within the plane
                           cross(axis, velocity) * sinTheta + // Circular motion, axis of rotation's plane * magnitude of perpendicular 
                           axis * dot(axis, velocity) * (1.0 - cosTheta); // Parallel to the axis of rotation,  adjusts the magnitude of parallel part
        return rotatedVelocity; 
    }
}
void CalculateBounceVelocityAtPosition(vec3 position, inout vec4 velocity)
{
    // Check for collision with the XZ plane
    vec3 normalXZ = vec3(0.0, 1.0, 0.0);
    float groundHeight = ubo.groundHeight;
    float restitution = ubo.restitution;
    float friction = 0.0; // No friction
    if (position.y <= groundHeight)
    {
        vec3 velocityNormal = dot(velocity.xyz, normalXZ) * normalXZ;
        vec3 velocityTangent = velocity.xyz - velocityNormal;
        velocityNormal *= -restitution;
        velocityTangent *= 1.0 - friction;
        velocity = vec4(velocityNormal + velocityTangent, velocity.w);
    }
}
vec3 ApplyGravity()
{
    return ubo.gravity.xyz * ubo.deltaTime;
}

// Intergration
vec3 CalculateVelocityAtPosition(vec3 position, vec3 particleVelocity) 
{
    vec3 newVelocity = particleVelocity; // Don't carry environment velocity overframe

    if(ubo.enableAdvection == 1)
    {
        newVelocity += CalculateFluidVelocityAtPosition(position);    // Addvection operation
    }
    if(ubo.enablVortex == 1)
    {
        newVelocity += CalculateVortexVelocityAtPosition(position);   // Vortex operation
    }
    if(ubo.enableSpiral == 1)
    {
        newVelocity += CalculateSpiralVelocity(newVelocity, position);// Spiral operation
    }
    return newVelocity;
}

struct RK2Result 
{
    vec3 position;
    vec3 velocity;
};

RK2Result RK2Integration(vec3 position, vec3 particleVelocity, float deltaTime)
{
    vec3 velocityAtInit = CalculateVelocityAtPosition(position, particleVelocity); 
    vec3 k1 = velocityAtInit * deltaTime;
    vec3 midpoint = position + 0.5 * k1;
    vec3 velocityAtMidpoint = CalculateVelocityAtPosition(midpoint, particleVelocity);
    vec3 k2 = velocityAtMidpoint * deltaTime;

    RK2Result result;
    result.position = position + k2;
    result.velocity = velocityAtMidpoint;
    return result;
}

// Helpers for testing rotation
vec4 normalizeQuaternion(vec4 q) 
{
    float length = sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
    return q / length;
}
vec4 angleAxis(float angle, vec3 axis) 
{
    vec3 normalizedAxis = normalize(axis);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return vec4(normalizedAxis * s, cos(halfAngle));
}
vec4 quatMultiply(vec4 q1, vec4 q2) 
{
    vec3 imaginary = cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz;
    float real = q1.w * q2.w - dot(q1.xyz, q2.xyz);
    return vec4(imaginary, real);
}

void main() 
{
    uint index = gl_GlobalInvocationID.x;  // 0 ~ 65536
    Particle particleIn = particlesIn[index];
    // Do NOT do MVP calculations here, or it will we reiterated
    //particlesOut[index].position = particleIn.position + particleIn.velocity * ubo.deltaTime;  
    particlesOut[index].rotation = particleIn.rotation;
    particlesOut[index].scale = particleIn.scale;
    //particlesOut[index].velocity = particleIn.velocity;
    particlesOut[index].color = particleIn.color;
    particlesOut[index].startPosition = particleIn.startPosition;
    particlesOut[index].startRotation = particleIn.startRotation;
    particlesOut[index].startScale = particleIn.startScale;
    particlesOut[index].startVelocity = particleIn.startVelocity;
    particlesOut[index].lifeTime = particleIn.lifeTime;
    particlesOut[index].remainingLifetime = particleIn.remainingLifetime - ubo.deltaTime;


    // Apply environment forces
    RK2Result rk2Result = RK2Integration(particleIn.position.xyz, particleIn.velocity.xyz, ubo.deltaTime);
    particlesOut[index].position = vec4(rk2Result.position.xyz, particleIn.position.w);
    vec4 newVelocity = particleIn.velocity;
    if(ubo.enableGravity == 1)
    {
        newVelocity += vec4(ApplyGravity(), 0.0); // Gravity operation
    }
    if(ubo.enableBounce == 1)
    {
         CalculateBounceVelocityAtPosition(particlesOut[index].position.xyz, newVelocity); // Bounce operation
    }
    particlesOut[index].velocity = newVelocity;


    // Recycle if life time ended
    if ( particlesOut[index].remainingLifetime <= 0.0)
    {
        particlesOut[index].position = particleIn.startPosition;
        particlesOut[index].rotation = particleIn.startRotation;
        particlesOut[index].scale = particleIn.startScale;
        particlesOut[index].velocity = particleIn.startVelocity;
        particlesOut[index].remainingLifetime = particleIn.lifeTime;
    }


//    //// Rotation test
//    // Calculate random rotation
//    vec3 randomAxis = normalize(particleIn.velocity.xyz); 
//    float randomAngle = length(particleIn.velocity.xyz) * ubo.deltaTime; 
//    vec4 randomRotation = angleAxis(randomAngle, randomAxis); 
//    // Combine new random rotation with the existing rotation
//    particlesOut[index].rotation = normalizeQuaternion(quatMultiply(particleIn.rotation, randomRotation));
}