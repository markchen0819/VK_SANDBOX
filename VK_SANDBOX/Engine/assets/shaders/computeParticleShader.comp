#version 450

struct Particle
{
	vec4 position;
    vec4 rotation;
    vec4 scale;
	vec4 velocity;
    vec4 color;

    vec4 startPosition;
    vec4 startRotation;
    vec4 startScale;
	vec4 startVelocity;

	float lifeTime;
    float remainingLifetime;
};

layout (std140, binding = 0) uniform ParameterUBO
{
    float deltaTime; 
    float accumulatedTime;
    int enableAdvection;
    int enablVortex; 
    float kappa;
    float tau; 
} ubo;

layout(std430, binding = 1) readonly buffer ParticleSSBOIn 
{
   Particle particlesIn[ ];
};

layout(std430, binding = 2) buffer ParticleSSBOOut 
{
   Particle particlesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Particle Count: 65536
// Thread Count per work group : 256
// Work Group Count: 65536/256
// Group1 0~255, Group2 256~511...


vec3 V0 = vec3(0,0,0);
vec3 u = vec3(0,1,0);
vec3 CalculateVortexVelocityAtPosition(vec3 position)
{
    float kappa = ubo.kappa; // rotation rate 
    float tau  = ubo.tau; //  tightness
    vec3 x = position - V0; // Translate position relative to the vortex center
    float distanceSquared = dot(x, x); // Compute squared distance from V0 to the position
    float projectionSquared = dot(x, u) * dot(x, u); // Compute squared distance of the projection on u
    float rSquared = abs(distanceSquared - projectionSquared); // Squared orthogonal distance to the axis
    rSquared = max(rSquared, 1e-6); // Avoid division by zero
    // Compute the velocity induced by the vortex at the particle's position
    vec3 velocity = kappa * cross(u, x) / pow(rSquared, tau / 2.0);
    return velocity;

}

vec3 flowDirection = vec3 (0, 1, 0);
vec3 flowCenter = vec3 (0, 1, 0);

vec3 CalculateFluidVelocityAtPosition(vec3 position)
{
    flowDirection = normalize(flowDirection);
    float maxVelocity = 3.0; 
    float flowWidth = 10.0;

    // (u dot v) v
    vec3 flowCenterToParticleVector = position - flowCenter;
    vec3 parallelVec = dot(flowCenterToParticleVector, flowDirection) * flowDirection;
    vec3 verticalVec = flowCenterToParticleVector - parallelVec;
    float distanceFromCenter = length(verticalVec);
    // Normalize distance to be between 0 and 1
    float normalizedDistance = distanceFromCenter / (0.5 * flowWidth);
    normalizedDistance = clamp(normalizedDistance, 0.0, 1.0); // Clamp to valid range
    // Calculate velocity magnitude (higher in the center, lower near the edges)
    float velocityMagnitude = maxVelocity * (1.0 - normalizedDistance);

    vec3 velocity = velocityMagnitude * flowDirection;
    return velocity;

    return vec3(0, 0.9, 0); // Placeholder - replace with your actual calculation
}

// Intergration
vec3 CalculateVelocityAtPosition(vec3 position, vec3 particleVelocity) 
{
    vec3 newVelocity = vec3 (0,0,0) + particleVelocity; // Don't carry environment velocity overframe

    if(ubo.enableAdvection == 1)
    {
        newVelocity += CalculateFluidVelocityAtPosition(position); // Addvection
    }
    if(ubo.enablVortex == 1)
    {
        newVelocity += CalculateVortexVelocityAtPosition(position);// Vortex
    }

    // Add gravity influence if enabled
    // Example: if (useGravity) { newVelocity += vec3(0, -9.81, 0); }
    // Add more forces here if necessary
    return newVelocity;
}

struct RK2Result 
{
    vec3 position;
    vec3 velocity;
};

RK2Result RK2Integration(vec3 position, vec3 particleVelocity, float deltaTime)
{
    vec3 velocityAtInit = CalculateVelocityAtPosition(position, particleVelocity); 
    vec3 k1 = velocityAtInit * deltaTime;
    vec3 midpoint = position + 0.5 * k1;
    vec3 velocityAtMidpoint = CalculateVelocityAtPosition(midpoint, particleVelocity);
    vec3 k2 = velocityAtMidpoint * deltaTime;

    RK2Result result;
    result.position = position + k2;
    result.velocity = velocityAtMidpoint;
    return result;
}


// Helpers for testing rotation
vec4 normalizeQuaternion(vec4 q) 
{
    float length = sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
    return q / length;
}
vec4 angleAxis(float angle, vec3 axis) 
{
    vec3 normalizedAxis = normalize(axis);
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    return vec4(normalizedAxis * s, cos(halfAngle));
}
vec4 quatMultiply(vec4 q1, vec4 q2) {
    vec3 imaginary = cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz;
    float real = q1.w * q2.w - dot(q1.xyz, q2.xyz);
    return vec4(imaginary, real);
}



void main() 
{
    uint index = gl_GlobalInvocationID.x;  // 0 ~ 65536

    Particle particleIn = particlesIn[index];

     // Do NOT do MVP calculations here, or it will we reiterated
    //particlesOut[index].position = particleIn.position + particleIn.velocity * ubo.deltaTime;  
    particlesOut[index].rotation = particleIn.rotation;
    particlesOut[index].scale = particleIn.scale;
    particlesOut[index].velocity = particleIn.velocity;
    particlesOut[index].color = particleIn.color;
    particlesOut[index].startPosition = particleIn.startPosition;
    particlesOut[index].startRotation = particleIn.startRotation;
    particlesOut[index].startScale = particleIn.startScale;
    particlesOut[index].startVelocity = particleIn.startVelocity;
    particlesOut[index].lifeTime = particleIn.lifeTime;
    particlesOut[index].remainingLifetime = particleIn.remainingLifetime - ubo.deltaTime;


    // Apply environment forces
     RK2Result rk2Result = RK2Integration(particleIn.position.xyz, particleIn.velocity.xyz, ubo.deltaTime);
     particlesOut[index].position = vec4(rk2Result.position.xyz, particleIn.position.w);


    // Recycle if life time ended
    if ( particlesOut[index].remainingLifetime <= 0.0)
    {
        particlesOut[index].position = particleIn.startPosition;
        particlesOut[index].rotation = particleIn.startRotation;
        particlesOut[index].scale = particleIn.startScale;
        particlesOut[index].velocity = particleIn.startVelocity;
        particlesOut[index].remainingLifetime = particleIn.lifeTime;
    }


//    //// Rotation test
//    // Calculate random rotation
//    vec3 randomAxis = normalize(particleIn.velocity.xyz); 
//    float randomAngle = length(particleIn.velocity.xyz) * ubo.deltaTime; 
//    vec4 randomRotation = angleAxis(randomAngle, randomAxis); 
//    // Combine new random rotation with the existing rotation
//    particlesOut[index].rotation = normalizeQuaternion(quatMultiply(particleIn.rotation, randomRotation));
//
//    //// Boundary test
//    // Flip movement at window border
//    if ((particlesOut[index].position.x <= -1.0 * 2) || (particlesOut[index].position.x >= 1.0 * 2))
//    {
//        particlesOut[index].velocity.x = -particlesOut[index].velocity.x;
//    }
//    if ((particlesOut[index].position.y <= -1.0 * 2) || (particlesOut[index].position.y >= 1.0 * 2))
//    {
//        particlesOut[index].velocity.y = -particlesOut[index].velocity.y;
//    }
//    if ((particlesOut[index].position.z <= -1.0 * 2) || (particlesOut[index].position.z >= 1.0 * 2)) 
//    {
//        particlesOut[index].velocity.z = -particlesOut[index].velocity.z;
//    }


}