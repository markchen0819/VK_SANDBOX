#version 450

struct GrassBlade
{
	vec4 position;
    vec4 rotation;
    vec4 scale;
    vec4 color;
    float windStrength;
    float tilt;
    uint perBladeHash;
};

layout (std140, binding = 0) uniform ParameterUBO
{
    float deltaTime; float accumulatedTime; float windStrength; float windSpeed;
    float chunkX; float chunkY; float gridSizeX; float gridSizeY;
    float areaSize; float swayStrength; float swayFrequency; int useGlobalTilt;
	float globalTilt; int enableControlPt; float bend; int enableRotationOverride;
	int showWorldNormals; int showLOD; int isHighLOD; int dummy1;
    vec4 windDirection;
    vec4 controlPtA;
    vec4 controlPtB;
    vec4 globalRotation;
} ubo;

layout(std430, binding = 1) readonly buffer GrassSSBOIn 
{
   GrassBlade grassBladesIn[ ];
};

layout(std430, binding = 2) buffer GrassSSBOOut 
{
   GrassBlade grassBladesOut[ ];
};

layout(set = 1, binding = 0) uniform sampler2D noiseTexture;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
// Particle Count: 65536
// Thread Count per work group : 256
// Work Group Count: 65536/256
// Group1 0~255, Group2 256~511...

// https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
uint hash(uint x) 
{
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

void main() 
{
    // Ideally should use compute shader to do GPU frustum culling
    // but time issue we'll use CPU frustum culling for now

    uint index = gl_GlobalInvocationID.x;  // 0 ~ 65536
    GrassBlade grassBladeIn = grassBladesIn[index];
    // Do NOT do MVP calculations here, or it will be reiterated
    grassBladesOut[index].position = grassBladeIn.position;  
    grassBladesOut[index].rotation = grassBladeIn.rotation;
    grassBladesOut[index].scale = grassBladeIn.scale;
    grassBladesOut[index].color = grassBladeIn.color;
    // Hash seeems to have some precision problems causing jitter, leave it for now
    grassBladesOut[index].perBladeHash = grassBladeIn.perBladeHash; //hash(index);
    grassBladesOut[index].tilt = grassBladeIn.tilt;

    // Wind
    vec2 scrollSpeed = vec2(ubo.windSpeed, ubo.windSpeed);
    vec2 directionFix = vec2(-1.0, -1.0);
    vec2 offset = normalize(ubo.windDirection.xz * directionFix) * ubo.accumulatedTime * scrollSpeed;

    // Chunk in Grid for noise texturing
    float chunkWidth = ubo.areaSize * ubo.gridSizeX;
    float chunkHeight = ubo.areaSize * ubo.gridSizeY;
    vec2 globalUV = vec2(ubo.areaSize * ubo.chunkX, ubo.areaSize * ubo.chunkY) + grassBladeIn.position.xz;
    vec2 uv = globalUV / vec2(chunkWidth, chunkHeight);
    vec2 scrolledUV = fract(uv + offset);
    float noiseValue = texture(noiseTexture, scrolledUV).r;
    grassBladesOut[index].windStrength = noiseValue;

}