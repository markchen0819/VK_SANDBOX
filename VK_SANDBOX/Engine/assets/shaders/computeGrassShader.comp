#version 450

struct GrassBlade
{
	vec4 position;
    vec4 rotation;
    vec4 scale;
    vec4 color;
    float windStrength;
    float tilt;
    uint perBladeHash;
};

layout (std140, binding = 0) uniform ParameterUBO
{
    float deltaTime; float accumulatedTime; float windStrength; float windSpeed;
    int chunkX; int chunkY; int gridSizeX; int gridSizeY;
    float areaSize; float swayStrength; float swayFrequency; int useGlobalTilt;
	float globalTilt;
    int enableControlPt;
    float bend;
    float d3;
	vec4 windDirection;
    vec4 controlPtA;
    vec4 controlPtB;
} ubo;

layout(std430, binding = 1) readonly buffer GrassSSBOIn 
{
   GrassBlade grassBladesIn[ ];
};

layout(std430, binding = 2) buffer GrassSSBOOut 
{
   GrassBlade grassBladesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;


layout(set = 1, binding = 0) uniform sampler2D noiseTexture;

// The rest of your shader code

// Particle Count: 65536
// Thread Count per work group : 256
// Work Group Count: 65536/256
// Group1 0~255, Group2 256~511...

// https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
uint hash(uint x) 
{
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

void main() 
{
    uint index = gl_GlobalInvocationID.x;  // 0 ~ 65536
    GrassBlade grassBladeIn = grassBladesIn[index];
    // Do NOT do MVP calculations here, or it will we reiterated
    grassBladesOut[index].position = grassBladeIn.position;  
    grassBladesOut[index].rotation = grassBladeIn.rotation;
    grassBladesOut[index].scale = grassBladeIn.scale;
    grassBladesOut[index].color = grassBladeIn.color;
    grassBladesOut[index].perBladeHash = hash(index);
    grassBladesOut[index].tilt = grassBladeIn.tilt;

    // Wind
    vec2 scrollSpeed = vec2(ubo.windSpeed, ubo.windSpeed);
    vec2 directionFix = vec2(-1.0, -1.0);
    vec2 offset = normalize(ubo.windDirection.xz * directionFix) * ubo.accumulatedTime * scrollSpeed;

    // Chunk in Grid for noise texturing
    float chunkWidth = ubo.areaSize * float(ubo.gridSizeX);
    float chunkHeight = ubo.areaSize * float(ubo.gridSizeY);
    vec2 globalUV = vec2(ubo.areaSize * float(ubo.chunkX), ubo.areaSize * float(ubo.chunkY)) + grassBladeIn.position.xz;
    vec2 uv = globalUV / vec2(chunkWidth, chunkHeight);
    vec2 scrolledUV = fract(uv + offset);

    float noiseValue = texture(noiseTexture, scrolledUV).r;
    grassBladesOut[index].windStrength = noiseValue;

}