#version 450

struct GrassBlade
{
	vec4 position;
    vec4 rotation;
    vec4 scale;
    vec4 color;
    float windStrength;
};

layout (std140, binding = 0) uniform ParameterUBO
{
    float deltaTime; 
    float accumulatedTime;
    float windStrength;
	float dummy2;
    int chunkX; 
	int chunkY;
	int gridSizeX; 
	int gridSizeY;
	vec4 windDirection;
} ubo;

layout(std430, binding = 1) readonly buffer GrassSSBOIn 
{
   GrassBlade grassBladesIn[ ];
};

layout(std430, binding = 2) buffer GrassSSBOOut 
{
   GrassBlade grassBladesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;


layout(set = 1, binding = 0) uniform sampler2D noiseTexture;

// The rest of your shader code

// Particle Count: 65536
// Thread Count per work group : 256
// Work Group Count: 65536/256
// Group1 0~255, Group2 256~511...


void main() 
{
    uint index = gl_GlobalInvocationID.x;  // 0 ~ 65536
    GrassBlade grassBladeIn = grassBladesIn[index];
    // Do NOT do MVP calculations here, or it will we reiterated
    grassBladesOut[index].position = grassBladeIn.position;  
    grassBladesOut[index].rotation = grassBladeIn.rotation;
    grassBladesOut[index].scale = grassBladeIn.scale;
    grassBladesOut[index].color = grassBladeIn.color;

    // Wind
    vec2 scrollSpeed = vec2(-0.1, -0.1);
    vec2 offset = ubo.windDirection.xz * ubo.accumulatedTime * scrollSpeed;

    // Chunk in Grid for noise texturing
    float chunkWidth = 20.0 * float(ubo.gridSizeX);
    float chunkHeight = 20.0 * float(ubo.gridSizeY);
    vec2 globalUV = vec2(20.0 * float(ubo.chunkX), 20.0 * float(ubo.chunkY)) + grassBladeIn.position.xz;
    vec2 uv = globalUV / vec2(chunkWidth, chunkHeight);
    vec2 scrolledUV = fract(uv + offset);

    float noiseValue = texture(noiseTexture, scrolledUV).r;
    grassBladesOut[index].windStrength = noiseValue;

}